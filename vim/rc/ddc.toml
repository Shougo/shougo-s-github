[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['context_filetype.vim', 'denops.vim']
on_event = 'InsertEnter'
hook_source = '''
  inoremap <silent><expr> <C-l> ddc#complete_common_string()
  inoremap <silent><expr> <TAB>
        \ pumvisible() ? '<C-n>' :
        \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
        \ '<TAB>' : ddc#manual_complete()

  call ddc#custom#patch_global(
      \ 'sources', has('nvim') ?
      \ ['around', 'deoppet', 'file'] :
      \ ['around', 'file'],
      \ )
  call ddc#custom#patch_global('sourceOptions', {
      \ '_': {
      \   'ignoreCase': v:true,
      \   'matchers': ['matcher_head'],
      \   'sorters': ['sorter_rank'],
      \   'converters': ['converter_remove_overlap'],
      \ },
      \ 'around': {
      \   'mark': 'A',
      \   'matchers': ['matcher_head', 'matcher_length'],
      \ },
      \ 'eskk': {'mark': 'eskk', 'matchers': [], 'sorters': []},
      \ 'necovim': {'mark': 'vim'},
      \ 'deoppet': {'mark': 'dp', 'dup': v:true},
      \ 'nextword': {
      \   'mark': 'nextword',
      \   'minAutoCompleteLength': 3,
      \   'isVolatile': v:true,
      \ },
      \ 'nvim-lsp': {
      \   'mark': 'lsp',
      \   'forceCompletionPattern': '\.\w*|:\w*|->\w*'
      \ },
      \ 'rtags': {
      \   'mark': 'R',
      \   'forceCompletionPattern': '\.\w*|:\w*|->\w*'
      \ },
      \ 'file': {
      \   'mark': 'F',
      \   'isVolatile': v:true,
      \   'minAutoCompleteLength': 1000,
      \   'forceCompletionPattern': '\S/\S*'
      \ },
      \ })
  call ddc#custom#patch_global('sourceOptions', {
      \ 'skkeleton': {
      \   'mark': 'skk',
      \   'matchers': ['skkeleton'],
      \   'sorters': [],
      \   'minAutoCompleteLength': 2,
      \ }})
  call ddc#custom#patch_filetype(
      \ ['help', 'markdown', 'gitcommit'], 'sources', has('nvim') ?
      \ ['deoppet', 'nextword', 'around'] :
      \ ['nextword', 'around']
      \ )
  call ddc#custom#patch_filetype(
      \ ['typescript', 'go'], 'sources', has('nvim') ?
      \ ['nvim-lsp', 'deoppet', 'around'] :
      \ ['nvim-lsp', 'around']
      \ )
  call ddc#enable()
'''

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nextword'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-zsh'
on_ft = 'zsh'
depends = 'ddc.vim'

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = ['vim', 'toml', 'help']
depends = 'ddc.vim'
hook_source = '''
  call ddc#custom#patch_filetype(
          \ ['vim'], 'sources', has('nvim') ?
          \ ['necovim', 'around', 'deoppet', 'file'] :
          \ ['necovim', 'around', 'file']
          \ )
'''

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'nvim-lspconfig'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_length'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-converter_remove_overlap'
on_source = 'ddc.vim'

[[plugins]]
repo = 'neovim/nvim-lspconfig'
depends = 'impatient.nvim'
on_ft = ['typescript', 'go']
if = 'has("nvim")'
depends = 'ddc.vim'
hook_source = '''
  lua << EOF
require'lspconfig'.denols.setup{}
require'lspconfig'.gopls.setup{}
EOF
'''

#[[plugins]]
#repo = 'tyru/eskk.vim'
#on_map = {ic = '<Plug>'}
#on_source = 'ddc.vim'
#hook_add = '''
#  imap <C-j>     <Plug>(eskk:toggle)
#  cmap <C-j>     <Plug>(eskk:toggle)
#'''
#hook_source = '''
#  let g:eskk#directory = expand('$CACHE/eskk')
#  let g:eskk#keep_state = 0
#  let g:eskk#debug = 0
#  let g:eskk#show_annotation = 1
#  let g:eskk#rom_input_style = 'msime'
#  let g:eskk#egg_like_newline = 1
#  let g:eskk#egg_like_newline_completion = 1
#  let g:eskk#tab_select_completion = 1
#  let g:eskk#start_completion_length = 2
#  let g:eskk#dictionary = {
#        \   'path': expand('$CACHE/skk-jisyo'),
#        \   'sorted': 0,
#        \   'encoding': 'utf-8',
#        \}
#  let g:eskk#large_dictionary = {
#        \   'path': has('win32') ?
#        \     '~/.config/SKK-JISYO.L' : '/usr/share/skk/SKK-JISYO.L',
#        \   'sorted': 1,
#        \   'encoding': 'euc-jp',
#        \}
#
#  if &term !=# 'gui' && &term !=# 'nvim' && &term !~# '^xterm'
#    " Use <> instead of ▽.
#    let g:eskk#marker_henkan = '<>'
#    " Use >> instead of ▼.
#    let g:eskk#marker_henkan_select = '>>'
#  endif
#
#  autocmd MyAutoCmd User eskk-initialize-pre call s:eskk_initial_pre()
#  function! s:eskk_initial_pre() abort
#    let t = eskk#table#new('rom_to_hira*', 'rom_to_hira')
#    call t.add_map('z ', '　')
#    call t.add_map('~', '〜')
#    call eskk#register_mode_table('hira', t)
#  endfunction
#
#  let &g:titlestring = "
#        \ %(%m%r%w%)%{eskk#statusline('[%s]').expand('%:p:~:.')}
#        \ %<\(%{fnamemodify(getcwd(), ':~')}\)"
#'''

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'


[[plugins]]
repo = 'Shougo/ddc-omni'

[[plugins]]
repo = 'Shougo/ddc-rtags'
on_ft = ['c', 'cpp']

[[plugins]]
repo = 'vim-skk/skkeleton'
on_map = {ic = '<Plug>(skkeleton-toggle)'}
depends = ['ddc.vim']
hook_add = '''
  imap <C-j> <Plug>(skkeleton-toggle)
  cmap <C-j> <Plug>(skkeleton-toggle)
'''
hook_source = '''
  "let g:skkeleton#debug = v:true
  call skkeleton#config({
        \ 'globalJisyo': has('win32') ?
        \     '~/.config/SKK-JISYO.L' : '/usr/share/skk/SKK-JISYO.L',
        \ 'eggLikeNewline': v:true,
        \ 'registerConvertResult': v:true,
        \ })

  if &term !=# 'gui' && &term !=# 'nvim' && &term !~# '^xterm'
    call skkeleton#config({
            \ 'markerHenkan': '<>',
            \ 'markerHenkanSelect': '>>',
            \ })
  endif

  call skkeleton#register_kanatable('rom', {
        \ 'jj': 'escape',
        \ '~': ['〜', ''],
        \ "z\<Space>": ["\u3000", ''],
        \ })

  autocmd MyAutoCmd User skkeleton-enable-pre call s:skkeleton_pre()
  function! s:skkeleton_pre() abort
    " Overwrite sources
    let s:prev_buffer_config = ddc#custom#get_buffer()
    call ddc#custom#patch_buffer('sources', ['skkeleton'])
  endfunction
  autocmd MyAutoCmd User skkeleton-disable-pre call s:skkeleton_post()
  function! s:skkeleton_post() abort
    " Restore sources
    call ddc#custom#set_buffer(s:prev_buffer_config)
  endfunction

  let &g:titlestring = "
      \ %(%m%r%w%)%{skkeleton#mode().expand('%:p:~:.')}
      \ %<\(%{fnamemodify(getcwd(), ':~')}\)"
'''
